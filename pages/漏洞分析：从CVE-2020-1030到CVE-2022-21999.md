
# [从CVE-2020-1030到CVE-2022-21999（技术月刊投稿）.docx](https://www.yuque.com/attachments/yuque/0/2022/docx/12414108/1652420982214-0917b2ae-3931-4eb7-ae61-52bce32d5ead.docx?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2022%2Fdocx%2F12414108%2F1652420982214-0917b2ae-3931-4eb7-ae61-52bce32d5ead.docx%22%2C%22name%22%3A%22%E4%BB%8ECVE-2020-1030%E5%88%B0CVE-2022-21999%EF%BC%88%E6%8A%80%E6%9C%AF%E6%9C%88%E5%88%8A%E6%8A%95%E7%A8%BF%EF%BC%89.docx%22%2C%22size%22%3A645409%2C%22type%22%3A%22application%2Fvnd.openxmlformats-officedocument.wordprocessingml.document%22%2C%22ext%22%3A%22docx%22%2C%22status%22%3A%22done%22%2C%22taskId%22%3A%22u9274469c-a0e2-470a-a90c-eb6c4ddb547%22%2C%22taskType%22%3A%22upload%22%2C%22id%22%3A%22ua853571f%22%2C%22card%22%3A%22file%22%7D)

# 背景介绍
首先来看下本次发生漏洞的print spooler。顾名思义，这个组件是用来提供打印服务的，但值得注意的是，这是一个在所有windows 工作站和服务器中都有内置的组件，且它的特点是从系统启动就开始运行，直到系统关机。可以说，是一个非常适合用来作为攻击目标的组件。从2020年起，陆续有24个相关的漏洞爆出，其中很大一部分都是旧漏洞的补丁绕过。这次的CVE-2022-21999就是对CVE-2020-1030的两处补丁绕过，因此本次分析的重点就放在cve-2020-1030是如何造成提权的以及本次如何对cve-2020-1030进行绕过的。

print spooler的结构如下图所示：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1645600251545-509facbc-cc51-462a-ba02-79f42fdb0470.png#clientId=uc228c126-691f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=408&id=u1c2e346a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=408&originWidth=577&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13193&status=done&style=none&taskId=u75292ee9-ecdf-43a9-9195-2de1caa1ada&title=&width=577)<br />客户端有三种，本地的可以使用GDI（Graphics Device Interface）、Winspool.drv，远程的客户端是Win32spl.dll，这三种客户端都会和server端的spoolsv.exe以发送RPC请求的方式进行交互（我们需要观察的也是这个名字的进程），服务端通过spoolss.dll可以和print provider进行交互，spoolss.dll我们可以理解为一个router，print provider同样可以部署在本地或者远程，主要作用是实现spoolsv.exe没有的功能。这次涉及到的local print provider为localspl.dll。local print provider为所有本地端口可访问到的打印机提供任务控制和打印机管理。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1645512341202-ba66bc8a-6285-4549-b948-d1446d180901.png#clientId=ub2a8393e-0d73-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=557&id=u41e1f9f7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=557&originWidth=508&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36544&status=done&style=none&taskId=uc273d035-a97c-4e42-a683-4942311f50d&title=&width=508)


# CVE-2020-1030
拿到一个提权漏洞，首先需要思考的，就是：为什么可以造成提权？利用了什么原理？

其根本原理是利用可写权限，向特定位置文件夹中写入dll文件，并使用自带的库对该dll以SYSTEM身份进行调用，从而达到我们想要的目的。例如，如果我们提供一个可以用来新建管理员用户的dll，那么运行成功就会添加一个我们希望的管理员账户。CVE-2020-1030的复现截图如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1645606536823-b84688e3-ddba-44d1-9ed7-7bb473cd6514.png#clientId=u59b0d958-97a4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=239&id=u8daa0936&margin=%5Bobject%20Object%5D&name=image.png&originHeight=239&originWidth=961&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17777&status=done&style=none&taskId=ua6bea7e3-b1b3-4440-b114-150cf44ad0a&title=&width=961)

想要搞清楚这个漏洞的具体实现过程，就需要想清楚三个问题：如何进行文件写入、什么操作是我们可以利用的高权限操作以及如何进行恶意dll的调用。这三个问题也就是漏洞利用过程中的重点步骤。<br />对CVE-2020-1030的exp逻辑进行梳理：

1. AddPrinter 起点，为了获取一个管理员权限
2. Set SpoolDirectory to v4 driver directory
3. Check if AppVTerminator.dll exists 开始尝试重启spoolsv.exe
4. Call LoadLibraryEx (localspl!SplLoadLibraryTheCopyFileModule) with AppVTerminator.dll ->This will immediately terminate spoolsv.exe and SetPrinterDataEx will fail (RPC_S_CALL_FAILED)
5. Monitor spoolsv.exe process creation, timeout = 30 seconds
6. Skip spooler initialization if spool directory exists
7. Monitor spool directory creation
8. Force spooler initialization by calling localspl!BuildPrinterInfo via EnumPrinters
9. Wait for spooler directory; timeout = 5 minutes
10. Move payload to spool directory 写入文件
11. Get printer handle
12. Call LoadLibraryEx (localspl!SplLoadLibraryTheCopyFileModule) with our payload 调用写入的恶意dll

结合具体的利用过程对上面exp的各个步骤进行详细讲解：

1. 漏洞发生在用户开始添加一个打印机的时候（对应上述步骤1）。

根据AddPrinter函数格式，
```
HANDLE AddPrinter(
  _In_ LPTSTR *pName,
  _In_ DWORD  Level,
  _In_ LPBYTE pPrinter
);
```
其中，当添加的打印机是本地时pName为NULL，Level固定为2，pPrinter则是一个含有下列内容的结构体：
```
    printerInfo.pPrinterName = pszPrinterName;
    printerInfo.pDriverName = L"Microsoft Print To PDF";
    printerInfo.pPortName = L"PORTPROMPT:";
    printerInfo.pPrintProcessor = L"winprint";
    printerInfo.pDatatype = L"RAW";
    printerInfo.Attributes = PRINTER_ATTRIBUTE_HIDDEN;
```
因此，添加打印机的语句为：
```
hPrinter = AddPrinter(NULL, 2, (LPBYTE)&printerInfo);
```
这里有一个要点，是关于权限问题：为什么选择添加打印机作为漏洞利用的第一步？是因为AddPrinter返回handle的权限为PRINTER_ALL_ACCESS，**这个权限允许用户对spooler APIs进行操作**，即使用户是一个低权限账户。从下图可以看出，INTERACTIVE用户组拥有Manage Server的权限，而任何在本地或者远程登录的用户都属于这个组，也就是任何账户都拥有INTERACTIVE的权限，即manage server：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1645673279212-469d93da-86e4-4ed9-9f34-31bd93c5454b.png#clientId=ue880c55c-df76-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=704&id=tE1BP&margin=%5Bobject%20Object%5D&name=image.png&originHeight=704&originWidth=1436&originalType=binary&ratio=1&rotation=0&showTitle=false&size=104717&status=done&style=none&taskId=u7651394f-2dc3-4358-9420-56af0960de9&title=&width=1436)<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1645673637001-fc4d0d39-7673-4f21-abb9-6ce5105373a8.png#clientId=ue880c55c-df76-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=229&id=c2AkT&margin=%5Bobject%20Object%5D&name=image.png&originHeight=229&originWidth=658&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21062&status=done&style=none&taskId=u049a6055-dd3f-4ec7-a45c-c5c917a78d0&title=&width=658)

2. 添加一个version 4 driver directory（对应上述步骤2）：

通过process monitor可以观察到，spoolsv.exe会首先在这两个目录中查找可以使用的dll：

- **%SYSTEMROOT%\System32**
- **%SYSTEMROOT%\System32\spool\drivers\<ENVIRONMENT>\<DRIVERVERSION>**



构造一个不存在的dll，让spoolsv进行查找，可以发现确实他们是会在上面这两个目录下进行查找的：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1646029109071-a230d6a0-519c-49e1-aa57-151737fe336a.png#clientId=u697c22f3-f8e8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue49eaa9d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=188&originWidth=848&originalType=url&ratio=1&rotation=0&showTitle=false&size=36618&status=done&style=none&taskId=ub7845001-4cfb-4375-87fa-4abcc0925b5&title=)<br />图中第二行可以看到，程序尝试在%SYSTEMROOT%\System32\spool\drivers\x64\4中寻找dll，但由于在windows中，这个目录其实本身是不存在的，因此我们可以把恶意dll放在这个文件路径下，从而达成恶意dll的调用。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1646029373877-d6e1fe9d-e5e4-45ba-bf43-9e848823a822.png#clientId=u697c22f3-f8e8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=492&id=u1a953967&margin=%5Bobject%20Object%5D&name=image.png&originHeight=492&originWidth=1130&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43630&status=done&style=none&taskId=ue4cb0c14-f01e-49bb-9e2c-210338a1886&title=&width=1130)

但是这里有一个问题，由于它的父目录继承的权限是禁止低权限用户进行目录创建的，我们还是需要找其他的办法来创建这个目录。

这里需要用到一个注册表中叫做SpoolDirectory的值。当用户需要打印一个文档的时候，打印任务会被以**假脱机**的状态存储在一个预先设定的spool directory位置。由于用户的权限不一定，但都需要对这个位置进行读写操作，因此这个目录的权限是任意用户可写的。又因为这个位置是在注册表中被设置的，且每一个打印机的默认位置都可以分别设置，我们可以将我们新建的那个打印机的默认spool directory位置设置在%SYSTEMROOT%\System32\spool\drivers\x64\4，这样就可以成功获得对这个路径的写权限了。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1646030975487-a45153fd-f8c8-4310-9687-42722920c0d4.png#clientId=u697c22f3-f8e8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=125&id=u933c2819&margin=%5Bobject%20Object%5D&name=image.png&originHeight=125&originWidth=487&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13513&status=done&style=none&taskId=uba13d272-fe16-41dd-880e-4f2f794f3fb&title=&width=487)

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1646029768823-4a28b38d-ee78-47b1-a903-b30889b8d446.png#clientId=u697c22f3-f8e8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=698&id=u1c229c49&margin=%5Bobject%20Object%5D&name=image.png&originHeight=698&originWidth=1064&originalType=binary&ratio=1&rotation=0&showTitle=false&size=73026&status=done&style=none&taskId=u243c2dde-87cc-40b6-9b69-bc6444cfba9&title=&width=1064)<br />来查看一下两个文件夹之间权限的区别：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1646030526450-7d5e1461-8558-4c03-a311-c40a7ab5a9a3.png#clientId=u697c22f3-f8e8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=247&id=u683a050d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=247&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27944&status=done&style=none&taskId=u1703b253-d487-4565-b279-371e8189783&title=&width=962)<br />使用这种方法在x64下新增4文件夹后：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1646362065055-53e9c178-b2ec-4ce3-b461-850e34f596bd.png#clientId=u5740cb47-5d74-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=150&id=ue272c050&margin=%5Bobject%20Object%5D&name=image.png&originHeight=150&originWidth=754&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16143&status=done&style=none&taskId=ud4838b09-6dde-497e-a8f9-8f9fe06da45&title=&width=754)<br />可以看到确实权限是有变化的。

3. 调用AppVTerminator.dll终止spoolsv.exe进程，并等待其重启后写入AddUser.dll（对应上述步骤3-10）

AppVTerminator.dll这个dll的用处是可以终止spoolsv.exe进程，需要调用这个dll的原因是，上面的那种可以通过修改注册表中spool directory值来新建文件夹并赋予低权限用户在该文件夹中写权限的方法，只会在 **localspl!SplCreateSpooler**调用**localspl!BuildPrinterInfo时发生，而这个过程只会发生在当spooler这个服务初始化的时候**，使用AppVTerminator.dll可以触发恢复机制，在原本的进程被终结掉之后会重启一个新的spooler进程。

这里还涉及到通过对注册表中的配置文件的修改引入任意dll，在整个过程中被用了两次：一次是引入AppVTerminator.dll让程序重启，另一次就是引入我们自己的AddUser.dll用来添加管理员账户。

首先依旧是权限问题，修改配置文件需要用到的函数是SetPrinterDataEx，作为SetPrinterData的扩展，两个函数都需要一个printer handler具有PRINTER_ACCESS_ADMINISTER的权限，而通过AddPrinter获得的权限是PRINTER_ALL_ACCESS，也就是涵盖了PRINTER_ACCESS_ADMINISTER，可以进行配置文件的修改。这也是为什么我们要从AddPrinter开始攻击的原因，它获得的权限实在是太高了，即使有时无法添加local printer，在一些情况下依然可以使用添加remote printer的方法进行攻击。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1645681592534-ff5a2915-8f29-4c32-a5f9-c0e6a1adf764.png#clientId=ue880c55c-df76-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=438&id=ud4d0f99e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=438&originWidth=639&originalType=binary&ratio=1&rotation=0&showTitle=false&size=53778&status=done&style=none&taskId=u2f6930d1-73f7-4dcc-9b47-21b6b49b3b2&title=&width=639)

那么为什么只要修改注册表中对应的配置文件，就可以实现dll引入呢？这是由代码逻辑决定的，我们可以看到，在exp中调用的是SetPrinterDataEx：

```
dwStatus = SetPrinterDataEx(hPrinter, L"CopyFiles\\Payload", L"Module", REG_SZ, (LPBYTE)szDestination, cbData);
```
SetPrinterDataEx中会调用SplCopyFileEvent：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1646037088375-6f9ba145-6c38-4f8b-91dd-d8c9c263fb28.png#clientId=u958b397f-b4c5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=157&id=u3cf6936b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=157&originWidth=672&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9887&status=done&style=none&taskId=u24130730-abe1-41db-8e17-20f57b595e6&title=&width=672)

SplCopyFileEvent中会调用SplLoadLibraryTheCopyFileModule：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1646038420572-1968eda8-0be3-4f0d-9805-33c3c85be3ff.png#clientId=u958b397f-b4c5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=331&id=u7a04ef4a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=331&originWidth=783&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32703&status=done&style=none&taskId=ucb77f67b-5791-433c-a8fb-c3a8426217a&title=&width=783)<br />然后在SplLoadLibraryTheCopyFileModule中会调用到LoadLibraryW：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1646038441959-d834c0d8-0d48-4c07-8c49-2c1230a81208.png#clientId=u958b397f-b4c5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=157&id=ub6083fac&margin=%5Bobject%20Object%5D&name=image.png&originHeight=157&originWidth=603&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17318&status=done&style=none&taskId=u2a5eec0a-ddee-4f48-aace-ca62cb1554d&title=&width=603)<br />根据这个函数的介绍，我们可以知道，这就是真正实现dll调用的函数：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1646370898705-96fbbcd3-fb24-4cdf-96a7-7db8d9bc4af9.png#clientId=u5740cb47-5d74-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=122&id=ud23e29c9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=122&originWidth=906&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22455&status=done&style=none&taskId=u1295618a-345a-41c0-84b2-7cbaa928fa4&title=&width=906)<br />传入该函数的LibFileName会在上面提到的两个路径中进行查找，并在找到后进行调用。

这样基本就讲清了全部CVE-2020-1030 的漏洞利用逻辑， exp附在文章的最后，感兴趣的同学也可以自己试一试。



# CVE-2022-21999
这个是今年新爆出的一个漏洞，作为CVE-2020-1030的绕过，我们会更关心它到底绕过了哪里的补丁，以及用的什么方法进行的绕过。经过学习，这里存在两处绕过：

第一处发生在SplCopyFileEvent调用之前，CVE-2020-1030的补丁会检查当前用户是否有权限访问所提供的SpoolDirectory：

before:<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1645587985761-5792c42f-8d17-49e3-9f8c-862fe87b7b63.png#clientId=u4e762a77-0bde-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=121&id=OLq5w&margin=%5Bobject%20Object%5D&name=image.png&originHeight=121&originWidth=599&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9056&status=done&style=none&taskId=ueb980a33-b68e-4807-9cc6-b295db537aa&title=&width=599)<br />after:<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1645588166060-9c627a2d-6f46-4525-a0b6-1c1fd74f7626.png#clientId=u8ab24247-6dd7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=196&id=rlg4a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=196&originWidth=696&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16449&status=done&style=none&taskId=ue0dd7746-9751-49a9-a315-1b69621bee6&title=&width=696)<br />可以看到，在进行SplCopyFileEvent的处理前，打补丁之后的dll首先进行了IsValidSpoolDirectory的处理，这一步是为了检验传入的路径当前用户是否有权访问。<br />![1_iwZ_edXh3t7PPMG0PyA9Pw.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1646101407159-442871f4-cb63-47a5-bd2c-f1c96e772e7a.png#clientId=u23316fac-d4ca-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=u11ba6455&margin=%5Bobject%20Object%5D&name=1_iwZ_edXh3t7PPMG0PyA9Pw.png&originHeight=509&originWidth=895&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41024&status=done&style=none&taskId=u4f66216d-5d0a-4f97-8b42-60a0d62777f&title=)<br />这里主要关注的是AdjustFile这个函数，它的作用是把传入的路径转化为标准路径（canonical path）。比如把C:\spooldir\变为\\?\C:\spooldir\，然后会进行权限的检查，如果当前用户在这个路径下没有写权限，就会直接返回错误，无法进行后面的步骤。

这里我在自己分析的时候遇到了一点问题：我没办法从自己本地搭建的所有测试环境中找到对应的dll，很奇怪，有些甚至连最新漏洞都不能打的系统，dll看起来还是最开始的这一版，不知道是什么原因，有了解的大佬麻烦教教我~

绕过的方法是使用directory junction。这是一种和symbolic link有点像但是又不太一样的方法。下面简单对其进行一下介绍：

directory junction、和hard linkes以及symbolic links合起来组成了NTFS 文件系统的三种文件链接形式。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1646111867743-366d5acf-2c94-4f09-bb89-3e6912950707.png#clientId=u23316fac-d4ca-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=164&id=u7042652d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=164&originWidth=826&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27799&status=done&style=none&taskId=ua1bc2cbe-8a5c-4589-b5fb-6a8c94d4ea2&title=&width=826)

在网上可以找到完整的C#实现junctionpoint的代码（[https://gist.github.com/LGM-AdrianHum/260bc9ab3c4cd49bc8617a2abe84ca74](https://gist.github.com/LGM-AdrianHum/260bc9ab3c4cd49bc8617a2abe84ca74)）

简单来说，这种方法就是在进行检查前后使用不同juntion point来进行绕过对传入SpoolDriver的权限检查。在检查之前，我们设定SpoolDirectory为一个任意用户都可以访问到的地址，为了避免和已有文件冲突，这里选择临时生成一个文件夹，位置在C:\Users\User\AppData\Local\Temp下。<br />我们使用icacls命令来检查一下，确实低权限的User账户也有Full access（F）：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1646380989857-6f952b6e-b2e8-4b8f-8a7b-bbc516d196ef.png#clientId=u5740cb47-5d74-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=101&id=u04280c38&margin=%5Bobject%20Object%5D&name=image.png&originHeight=101&originWidth=822&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11036&status=done&style=none&taskId=u8adbbd71-d202-4031-9bac-c0105271d0a&title=&width=822)<br />在这里新建一个文件夹，此时是可以通过IsValidSpoolDirectory检查的，而我们随后把junction point改为GetDriverDirectory()获取到的printer driver directory—在这里也就是C:\Windows\system32\spool\DRIVERS\x64。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1646381740684-dbab5f81-766f-4ad8-aa54-19a01e21a72a.png#clientId=u5740cb47-5d74-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=46&id=u603354f9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=46&originWidth=957&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5324&status=done&style=none&taskId=u4d03638f-ab5f-4266-8adb-414bf63e158&title=&width=957)<br />但这个时候由于已经通过检查，就不会再有权限要求了。因此，SpoolDirectory就从\\localhost\C$\Users\User\AppData\Local\Temp\dedafcda-6cd2-44e2-b501-13d756b0cd4b\4被成功替换为了C:\Windows\system32\spool\DRIVERS\x64\4。

接下来就到了第二处绕过，位置在我们上面提到CVE-2020-1030的第8步，补丁在完成printer initialization之前进行了一次安全检查：

![1_ZXbmhvYkwwVPNvHkPtpbqw.png](https://cdn.nlark.com/yuque/0/2022/png/12414108/1646382531760-d8cff75a-dd45-42a7-abd6-634b13d86941.png#clientId=u5740cb47-5d74-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=u770f8ad5&margin=%5Bobject%20Object%5D&name=1_ZXbmhvYkwwVPNvHkPtpbqw.png&originHeight=358&originWidth=749&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28088&status=done&style=none&taskId=ubb4de564-601a-45c8-8884-b8165c95c95&title=)<br />也就是说，如果想要使用SplLoadLibraryTheCopyFileModule，所使用的dll必须位于打印机驱动文件夹（C:\Windows\System32\spool\drivers\x64\）内或者C:\Windows\System32\内（上面详细解释了为什么）。但在这一次的安全检查中，他会检查SpoolDirectory是不是指向打印机驱动文件夹，我们刚刚设置的SpoolDirectory无法通过安全检查，而如果想要通过，我们自己的AddUser.dll就没有办法被执行了。

解决方案是使用UNC路径。刚接触windows可能会对各种路径有点陌生，具体的区别可以参考微软的官方文档：<br />由于在spoolsv.exe的路径处理中，会将普通的DOS路径转化为canonical路径，但是如果我们传入一个UNC路径，比如：\\localhost\C$\spooldir\printers\，则会被getfinalpathnamebyhandlew函数处理为\\?开头的字符串，也就是\\?\\localhost\C$\Windows\System32\spool\drivers\x64\printers\。这个时候如果进行安全检查，会将去除前4个byte的字符串与C:\Windows\System32\spool\drivers\x64\进行比对，他俩很明显不一样，因此可以通过安全检查，从而实现补丁的绕过。（这里还是因为我没办法找到对应打过CVE-2020-1030补丁的dll，因此没办法详细调试，所以具体实现过程还需要再斟酌一下。）

在完成两个补丁的绕过之后，我们就成功实现了CVE-2022-21999的漏洞攻击，exp我同样附在附件里，感兴趣的同学可以自己尝试一下。
